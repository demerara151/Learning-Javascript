# プロジェクト概要

このバウンスボールのデモは面白いですが、ここではもう少しインタラクティブにするため、バウンスボールを捕まえたら食べてしまう、ユーザー制御された邪悪な円を追加します。また、バウンスボールや邪悪な円が継承できる一般的な`Shape`オブジェクトを作ることで、あなたのオブジェクト構築スキルも試してみましょう。最後に、残ったボールが数えられるスコアカウンターも追加してみましょう。
***
## 1.オブジェクト（クラス）を作る

（１）`Shape`というクラスを作り、`x, y, velX, velY`というプロパティを定義してください。  
色（color）とサイズ（size）のプロパティはここでは定義しません。  
また、ボールが存在するか（邪悪な円に食べられていないか）どうかを追跡するために使う`exists`というプロパティも定義する必要があります。これは真偽値（true/false）である必要があります。  
（２）次に`Ball`というクラスを、`Shape`から、`x, y, velX, velY, exists`プロパティを全て継承して作成してください。classの宣言は用意してあります。  
また、*color* と *size* プロパティを定義する必要があります。  
`Ball`のコンストラクターを適切に設定してください。

`Ball`に、`draw()`、`update()`、`collisionDetect()`という3種類のメソッドを定義します。これはこちらで用意します。

また、`new Ball()`で`Ball`を実体化する際に新しい引数を追加する必要があります。  
`exists`は 5番目の引数にする必要があり、`true`を指定する必要があります。
***
## 2.EvilCircle の定義

さあ、悪者 EvilCircle の出番です！ 私たちのゲームに邪悪な円は1つしか登場しませんが、練習のためにあえて、`Shape`から継承するクラスを使用して定義します。後で、他のプレイヤーによって制御される円、あるいは、コンピューター制御の別の邪悪な円をいくつか加えたいと思うかもしれません。おそらく、あなたは単一の邪悪な円の世界を引き継いでいくつもりはないでしょうが、今回のテストのためにはこれで十分です。

（３）`EvilCircle`は、`x, y, velX, velY, exists`を`Shape`から継承しますが、`velX`と`velY`の値は常に20になるように定義します。

これは `super(x, y, 20, 20, exists)`のように呼び出します。

次のように、独自のプロパティも定義する必要があります：

    color — 'white'
    size — 10

ここでも、継承したプロパティをコンストラクターの引数として定義し、正しく設定することを忘れないでください。
***
## 3.`EvilCircle`のメソッドの定義

`EvilCircle`には、以下に示す 4 つのメソッドがあります。
### `draw()`

（４）このメソッドは、`Ball`の`draw()`メソッドと同じく、キャンバス上にオブジェクトインスタンスを描画するという目的を持ちます。とても良く似た動作をするので、`ball.draw()`の定義をコピーすることから始めます。次に、以下の変更を行います。

邪悪な円は塗りつぶしせず、枠線（ストローク）だけを持たせたいと思います。そのために、`fillStyle`と`fill()`をそれぞれ`strokeStyle`と`stroke()`に変更します。  
また、線を少し太くすれば、邪悪な円が少し分かりやすくなります。これは、`beginPath()`呼び出しの後のどこかで`lineWidth`の値（3で十分でしょう）を設定することで実現できます 。

### `checkBounds()`

（５）このメソッドは、`Ball`の`update()`関数の最初の部分と同じ機能、すなわち、邪悪な円が画面の端から出そうになったら出ないようにする機能を持ちます。先ほどと同様に、`ball.update()`の定義をほぼコピーするだけでできますが、いくつか変更する必要があります。

最後の 2行を削除します。後で見られるように、別の方法で邪悪な円を動かすので、フレーム毎に邪悪な円の位置を自動的に更新する必要はありません。
>論理チェックで`true`を返す場合、`if()`文の内部で`velX / velY`を更新したくありません。代わりに `x / y`の値を変更して、邪悪な円が画面上に少し跳ね返ってくるようにします。邪悪な円の`size`プロパティを（必要に応じて）増減させることは理にかなっています。

### `setControls()`

（６）このメソッドは、イベントリスナー`onkeydown`を`window`オブジェクトに追加し、特定のキーボードキーが押されたときに、邪悪な円を動かします。次のコードブロックは、メソッド定義の中に置く必要があります。

```Javascript
window.onkeydown = e => {
	if (e.key === "a") {
		this.x -= this.velX
	} else if (e.key === "d") {
		this.x += this.velX
	} else if (e.key === "w") {
		this.y -= this.velY
	} else if (e.key === "s") {
		this.y += this.velY
	}
}
```

キーが押されると、イベントオブジェクトの`keyCode`プロパティを調べて、どのキーが押されているかを確認します。押されたキーが、指定された4つのキーコードの 1 つである場合、邪悪な円は左/右/上/下に移動します。

### `collisionDetect()`

（７）このメソッドは `Ball`の`collisionDetect()`メソッドと非常によく似た方法で動作するので、そのコピーをこの新しいメソッドの基礎として使用することができます。しかし、いくつかの違いがあります。

外側の *if文*では、反復処理中のボールが、チェックを行っているボールと同じであるかをチェックする必要はなくなりました。なぜなら、それは邪悪な円であって、ボールではないからです！ その代わりに、チェックされているボールが存在するかどうかを確認（どのプロパティでこれを行うことができるでしょうか？）するテストを行う必要があります。存在しなければ、それはすでに邪悪な円によって食べられているので、再度チェックする必要はありません。  
内部の *if文*では、衝突が検出されたときにオブジェクトの色を変更する必要がなくなりました。その代わりに、邪悪な円と衝突するボールをもう存在しないように設定します（どうやって実行すると思いますか？）。
***
## 4.プログラムに邪悪な円を持ち込む

さて、邪悪な円を定義したので、実際にそれを画面に表示させる必要があります。そのためには、`loop()`関数をいくつか変更する必要があります。

（８）まず、（必要な引数を指定して）新しい邪悪な円オブジェクトインスタンスを作成し、（９）その`setControls()`メソッドを呼び出します。これら2つの処理は一度だけ実行すればよく、ループの繰り返し毎に行う必要はありません。  
（１０）すべてのボールをループして、ボールが存在する場合にのみ、それぞれの`draw()`、`update()`、`collisionDetect()`が呼び出されるようにします。  
（１１）ループの各繰り返しで、邪悪な円インスタンス（`evil`）の`draw()`、`checkBounds()`、および `collisionDetect()`メソッドを呼び出します。
***
## 5.スコアカウンターの実装

スコアカウンターを実装するには、次の手順に従います。

* *HTML*ファイルの`<h1>`要素の直下に、「Ball count：」というテキストを含む`<p>`要素を追加します。
* *CSS*ファイルには、次のスタイルを追加します：

```css
p {
    position: absolute;
    margin: 0;
    top: 35px;
    right: 5px;
    color: #aaa;
}
```

* JavaScript では、次の更新を行います：
    * （１２）段落への参照を格納する変数を作成します。
    * （１３）何らかの方法で画面上のボールの数をカウントしてください。
    * （１４）ボールを画面上に追加するたびにカウントを増加させ、更新されたボールの数を表示します。
    * （１５）邪悪な円がボールを食べる（存在を消す）たびにカウントを減らし、更新されたボールの数を表示します。
***
**ヒントとTips**

    このテストはかなり難しいです。各ステップをゆっくりと注意深く行ってください。
    それぞれのステージを作業した後のデモを、別々のコピーとして保管しておけば、後で困ったときに参照することができます。
